// background.ts
// Central router for extension messages with concurrency control
import { ChromeStorageService } from './core/storage-service';
import { WriteQueueService, ConcurrencyService, DEFAULT_CONCURRENCY_CONFIG } from './core/concurrency-service';
import { Message } from './core/types';
import { ChromeEnvConfigService } from './core/env-config';
import { DEFAULT_AI_CONFIG } from './core/ai-config';

// Minimal shim for the `chrome` global to avoid TypeScript complaints in this sandbox.
// In a real extension build, install `@types/chrome` and remove this shim.
declare const chrome: any;

// Initialize concurrency services
const writeQueue = new WriteQueueService();
const concurrencyService = new ConcurrencyService(writeQueue, {
  ...DEFAULT_CONCURRENCY_CONFIG,
  logOperations: true, // Enable logging for debugging
  enableMetrics: true
});

// Initialize storage service with concurrency control
const storage = new ChromeStorageService(concurrencyService);

// Initialize AI configuration service
const envConfigService = new ChromeEnvConfigService();

// Initialize AI configuration on startup
async function initializeAIConfig() {
  try {
    const config = await envConfigService.loadAIConfig();
    
    // Set default API key if not present
    if (!config.apiKey) {
      const defaultConfig = { ...DEFAULT_AI_CONFIG, apiKey: 'AIzaSyCtaRiI3DVet0qtvLyLanIHZn6n-dpIw7Q' };
      await envConfigService.saveConfig(defaultConfig);
      console.log('BACKGROUND: AI configuration initialized with default API key');
    } else {
      console.log('BACKGROUND: AI configuration loaded from storage');
    }
  } catch (error) {
    console.error('BACKGROUND: Failed to initialize AI configuration:', error);
  }
}

// Initialize on startup
initializeAIConfig();

chrome.runtime.onMessage.addListener((message: Message, sender: any, sendResponse: (response: any) => void) => {
  console.log('BACKGROUND: received message', message);

  switch (message.type) {
    case 'GET_PROMPTS_REQUEST':
      storage.getPrompts().then(prompts => {
        sendResponse({ type: 'GET_PROMPTS_RESPONSE', payload: prompts });
      });
      break;
    
    case 'SAVE_PROMPT_REQUEST':
      console.log('BACKGROUND: saving prompt atomically', message.payload);
      storage.savePromptAtomic({
        id: '', // Will be generated by storage service
        name: message.payload.name,
        template: message.payload.template,
        description: message.payload.description
      }).then(() => {
        console.log('BACKGROUND: prompt saved successfully with atomic operation');
        sendResponse({ type: 'SAVE_PROMPT_RESPONSE', payload: { success: true } });
      }).catch((error) => {
        console.error('BACKGROUND: failed to save prompt atomically', error);
        sendResponse({ type: 'SAVE_PROMPT_RESPONSE', payload: { success: false, error: error.message } });
      });
      break;

    case 'DELETE_PROMPT_REQUEST':
      console.log('BACKGROUND: deleting prompt atomically', message.payload);
      storage.deletePromptAtomic(message.payload.id).then(() => {
        console.log('BACKGROUND: prompt deleted successfully with atomic operation');
        sendResponse({ type: 'DELETE_PROMPT_RESPONSE', payload: { success: true } });
      }).catch((error) => {
        console.error('BACKGROUND: failed to delete prompt atomically', error);
        sendResponse({ type: 'DELETE_PROMPT_RESPONSE', payload: { success: false, error: error.message } });
      });
      break;

    case 'GET_CONCURRENCY_METRICS_REQUEST':
      console.log('BACKGROUND: providing concurrency metrics');
      storage.getConcurrencyMetrics().then(metrics => {
        sendResponse({ type: 'GET_CONCURRENCY_METRICS_RESPONSE', payload: metrics });
      }).catch((error) => {
        console.error('BACKGROUND: failed to get concurrency metrics', error);
        sendResponse({ type: 'GET_CONCURRENCY_METRICS_RESPONSE', payload: null });
      });
      break;

    // Context management handlers
    case 'GET_CONTEXTS_REQUEST':
      console.log('BACKGROUND: getting contexts');
      storage.getContexts().then(contexts => {
        sendResponse({ type: 'GET_CONTEXTS_RESPONSE', payload: contexts });
      }).catch((error) => {
        console.error('BACKGROUND: failed to get contexts', error);
        sendResponse({ type: 'GET_CONTEXTS_RESPONSE', payload: [] });
      });
      break;
    
    case 'SAVE_CONTEXT_REQUEST':
      console.log('BACKGROUND: saving context atomically', message.payload);
      storage.saveContextAtomic({
        id: '', // Will be generated by storage service
        name: message.payload.name,
        text: message.payload.text
      }).then(() => {
        console.log('BACKGROUND: context saved successfully with atomic operation');
        sendResponse({ type: 'SAVE_CONTEXT_RESPONSE', payload: { success: true } });
      }).catch((error) => {
        console.error('BACKGROUND: failed to save context atomically', error);
        sendResponse({ type: 'SAVE_CONTEXT_RESPONSE', payload: { success: false, error: error.message } });
      });
      break;

    case 'DELETE_CONTEXT_REQUEST':
      console.log('BACKGROUND: deleting context atomically', message.payload);
      storage.deleteContextAtomic(message.payload.id).then(() => {
        console.log('BACKGROUND: context deleted successfully with atomic operation');
        sendResponse({ type: 'DELETE_CONTEXT_RESPONSE', payload: { success: true } });
      }).catch((error) => {
        console.error('BACKGROUND: failed to delete context atomically', error);
        sendResponse({ type: 'DELETE_CONTEXT_RESPONSE', payload: { success: false, error: error.message } });
      });
      break;
  }
  return true; // Indicates you'll send a response asynchronously
});
